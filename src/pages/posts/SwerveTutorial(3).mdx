---
layout: "@/layouts/BlogPost"
title: FRC Swerve Drive Tutorial - Part 3
publishDate: 8 December 2022
description: The Drive Train
tags: ["swerve-drive", "tutorial"]
draft: true
---
# Overview
In this post, I will go over the most complex MANDATORY component of swerve drive. Although I will be referring to this part as the "drive train", it is beneficial to think of it as a "conductor" for the entire robot; the "conductor" will take in input directly from the user (2875 uses a dual joystick HOSAS control scheme), convert the inputs to a "field-relative" version, split the inputs up into individual commands for each module. This installment in the tutorial will go over the bare minimum for a field oriented swerve drive "conductor". In future installments, I will continue to develop the swerve drive train by adding more features such as angular drift correction and positional drift correction. 

## Requirements
So far throughout this tutorial series, the math has been relatively light and simple. However, now, you will need (at least) a basic understanding of vectors. The introduction to vector mathematics given in most AP/Honors level high school physics courses should generally be sufficient; however, if you feel a little unsure, now is a great time to brush up on your knowledge ((MathIsFun)[https://www.mathsisfun.com/algebra/vectors.html], (Wikipedia)[https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics)]). The most important concepts are vector addition, and an understanding of the differences between polar vectors and Cartesian vectors.

## A Brief Note on WPILib
At this point in the tutorial, you may again be wondering "Why not simply use the WPILib swerve utilities?". The answer to this question, is that you certainly can; however, if you do you will lose many of the benefits of creating your own custom swerve drive. Even if you use the WPILib utilities, I still recommend going through this tutorial so that you can gain a true understanding of their workings under the hood. What I have been referring to as the "drive train" or "conductor" is roughly equivalent to the `SwerveDriveKinematics` class found in WPILib. After this, you should have enough of an understanding of swerve drive to build an autonomous, and the various other QOL additions on your own, but I will still continue with the tutorial series in order to make it easier. Regardless of if you follow this tutorial series to the "t" or branch off significantly, the better understanding you will gain into swerve drive will more than pay for itself in terms of features you will be able to add over the WPILib utilities. For a brief example, 2875's swerve autonomous contains a few features that the WPILib autonomous swerve utilities do not: an autonomous that is both PID corrected and motion profiled, as well as PID based teleop drift correction through the use of odometry and a gyroscope. While it is possible to add these features using the WPILib, it will be more difficult and may involve the modification of their libraries.

# Utility
The train is the most math-involved piece of swerve drive, and thus it will have the most utility methods. 

To begin, we will create some methods to handle conversions between the two coordinate systems we will be using: polar and Cartesian.
```java
public double[] polarToCartesian(double theta, double r) {
    //convert a polar coordinate (angle (theta) and magnitude (r) to cartestian (x, y))
    double x = r * Math.cos(Math.toRadians(theta));
    double y = r * Math.sin(Math.toRadians(theta));
    return new double[] { x, y };
}
```
This method performs some basic trigonometry to convert from a polar coordinate to a Cartesian coordinate. If you are using Java and trigonometry, make sure to remember to convert degrees to radians and vice versa, otherwise you may end up with many hours of annoyance (I sure did) when you forget.

Our next method will do the opposite, and this will be slightly more complex.
```java
public double[] cartesianToPolar(double x, double y) {
    double r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    double theta = Math.toDegrees(Math.atan2(y, x));

    return new double[] { theta, r };
}
```
I recommend taking some time to go over these methods and make sure you fully understand the underlying concepts and math, as they will be used repeatedly throughout swerve. The `Mathatan2()` is of particular importance; you may think it is a simple tangent function, however, in reality, it does much (more)[https://en.wikipedia.org/wiki/Atan2]. The function solves the issue that arises with the existence of multiple quadrants in the coordinate plane, and the issue that comes with converting an (x, y) coordinate to an angle relative to the positive x-axis. If you take a few minutes to think about this problem, you will realize that there are several situations wherein you must convert the coordinate differently, and this is dependent on its quadrant. The `Math.atan2()` function saves you some time, and code. 


